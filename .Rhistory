plot(mC_D.nb, main="NB")
par(mfrow=c(4,4))
plot(mC_D.nb, main="NB")
plot(mC_D.nb.slope, main="Slope")
plot(mC_D.nb.solar, main= "Solar")
plot(mC_D.nb.all, main = "All")
mC_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE  + scale(SLOPE) + (TREAT*SITE), link = log, data = CONIF_dens)
#solar not significant, but at least the values are sensible.
summary(mC_D.nb.slope)
summary(mC_D.nb)	#AIC -924
summary(mC_D.nb.slope)#AIC -926
#solar not significant, but at least the values are sensible.
summary(mC_D.nb.slope)
# Different way of subsetting, base R
DECID_dens <- subset(dens, dens$DIV == "d")
# the plots are duplicated with one entry per species, so this reduces it to one value per plot
cnt <- aggregate(DECID_dens$COUNT_HA, list(DECID_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
trt <- aggregate(DECID_dens$TREAT, list(DECID_dens$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
DECID_dens_new <- cbind(cnt, trt[,2])						#combines
temp <- merge(x=DECID_dens_new, y=DECID_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
temp2 <- temp[duplicated(temp[,1]),]										#merging and removing
temp3 <- temp2[duplicated(temp2[,1]),]        # have to loop through, since there's so many more species
temp4 <- temp3[duplicated(temp3[,1]),]        # absolutely sure there's a faster way to do this, just wanted to get it done
temp5 <- temp4[duplicated(temp4[,1]),]
DECID_dens_new <- temp5[duplicated(temp5[,1]),]
rm(temp,temp2, temp3, temp4, temp5, cnt, trt) 				# cleaning up workspace
DECID_dens <- DECID_dens_new %>%
rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use							#back to original name so code below works
hist(DECID_dens$COUNT)									#check
dev.off()
hist(DECID_dens$COUNT)									#check
mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
mD_D <- 		glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = DECID_dens)
mD_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = DECID_dens)
par(mfrow=c(3,4))
plot(mD_D, main="Poisson")
plot(mD_D_qp, main="Quasi-poisson")
plot(mD_D.nb, main="NB")
summary(mD_D)
summary(mD_D_qp)
summary(mD_D.nb)
summary(mD_D_qp)
# parameters
summary(mD_D)
mD_D.nb.all <- 	glm.nb(COUNT ~ as.factor(TREAT) + SITE + scale(SLOPE) + (TREAT*SITE),link = log,
data = DECID_dens)
summary(mD_D.nb.all)
mD_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  +  scale(SOLAR) + (TREAT*SITE),link = log, data = DECID_dens)
summary(mD_D.nb.solar)
mD_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = DECID_dens)
summary(mD_D.nb.slope)
mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + scale(SOLAR) + (TREAT*SITE),link = log,
data = DECID_dens)
mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
mD_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  +  scale(SOLAR) + (TREAT*SITE),link = log, data = DECID_dens)
mD_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = DECID_dens)
mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + scale(SOLAR) + (TREAT*SITE),link = log,
data = DECID_dens)
par(mfrow=c(4,4))
plot(mD_D.nb, main="NB")
plot(mD_D.nb.slope, main="Slope")
plot(mD_D.nb.solar, main= "Solar")
plot(mD_D.nb.all, main = "All")
#bringing in other covariates
#adding them into the glm above
mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
mD_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  +  scale(SOLAR) + (TREAT*SITE),link = log, data = DECID_dens)
mD_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = DECID_dens)
mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + scale(SOLAR) + (TREAT*SITE),link = log,
data = DECID_dens)
mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + SOLAR + (TREAT*SITE),link = log,
data = DECID_dens)
summary(mD_D.nb.all)
summary(mD_D.nb)
plot(mD_D.nb.solar, main= "Solar")
summary(mD_D.nb) # AIC 1087
summary(mD_D.nb.solar) # AIC 1078
# bringing in data
ba <- read.csv(("ba.csv"), stringsAsFactors = F)
# removing unburned sites
ba <- ba[ba$TREAT != 0,]
# looking at format of data, first three rows
ba[1:3,]
DECID_BA <- subset(ba, ba$DIV == "d")
DECID_BA$QUAD[DECID_BA$QUAD == 2] <- 50	#assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
DECID_BA$QUAD[DECID_BA$QUAD == 1] <- 100
DECID_BA$QUAD[DECID_BA$QUAD == .1] <- 1000
DECID_BA$QUAD[DECID_BA$QUAD == .2] <- 500
#calc basal area
DECID_BA$BA <- (pi * (DECID_BA$DBH/2)^2)/10000	#convert to ba and cm2 to m2. Just pi*r2
DECID_BA$BA_ha <- DECID_BA$BA * DECID_BA$QUAD		#multiply by expansion factor
ba.plot <- aggregate(DECID_BA$BA_ha, list(DECID_BA$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
ba.trt <- aggregate(DECID_BA$TREAT, list(DECID_BA$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
DECID_ba_new <- cbind(ba.plot, ba.trt[,2])						#combines
names(DECID_ba_new) <- c("PLOT","BA","TREAT")
ba.site <- cbind(DECID_BA$SITE,DECID_BA$PLOT)
temp <- as.data.frame(ba.site[!duplicated(ba.site[,2]),])
names(temp) <- c("SITE","PLOT")
DECID_BA <- merge(DECID_ba_new,temp,by="PLOT")	#double check all is well with the rows - right site/treatment/value
#histogram
hist(DECID_BA$BA)
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in BA
order <- as.vector(DECID_BA$PLOT) # don't worry that its 42, remember this doesnt include unburned
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order))
# adding in attributes to density file
DECID_BA$SLOPE <- attrib$SLOPE
DECID_BA$ELEV <- attrib$ELEVATION
DECID_BA$SOLAR <- attrib$SOLAR
mD_BA.log <- lm(log(BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)						#models E[log(y)]
mD_BA.ga <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = gaussian(link = "log"), data = DECID_BA)	#models log[E(y)]
mD_BA.gamma <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
#another option, look up lognormal distributions
BA_logn <- lognlm((BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)
par(mfrow=c(3,4))
plot(mD_BA.log, main= "Logged")
plot(mD_BA.ga, main="Guassian")
plot(mD_BA.gamma, main="Gamma")
par(mfrow=c(4,4))
plot(mD_BA.log, main= "Logged")
plot(mD_BA.ga, main="Guassian")
plot(mD_BA.gamma, main="Gamma")
plot(BA_logn, main = "Lognorm")
#another option, look up lognormal distributions
BA_logn <- lognlm((BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)
ba$TREAT <- as.factor(ba$TREAT)
mD_BA.log <- lm(log(BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)						#models E[log(y)]
mD_BA.ga <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = gaussian(link = "log"), data = DECID_BA)	#models log[E(y)]
mD_BA.gamma <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
#another option, look up lognormal distributions
BA_logn <- lognlm((BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)
par(mfrow=c(4,4))
plot(mD_BA.log, main= "Logged")
plot(mD_BA.ga, main="Guassian")
plot(mD_BA.gamma, main="Gamma")
plot(BA_logn, main = "Lognorm")
par(mfrow=c(1,4))
plot((DECID_BA$BA),residuals(mD_BA.log),main="log"); abline(h=0)
plot((DECID_BA$BA),residuals(mD_BA.ga), main="Gaussian"); abline(h=0)	#pretty clear Gaussian is not great.
plot((DECID_BA$BA),residuals(mD_BA.gamma), main="Gamma"); abline(h=0)
plot((DECID_BA$BA),residuals(BA_logn), main="Lognormal"); abline(h=0)
# parameters
summary(mD_BA.log)
summary(mD_BA.ga)
summary(mD_BA.gamma)
summary(BA_logn)
sqrt(mean(mD_BA.log$residuals^2))
sqrt(mean(mD_BA.ga$residuals^2))
sqrt(mean(mD_BA.gamma$residuals^2))
sqrt(mean(BA_logn$residuals^2))
mD_BA.gamma <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
mD_BA.gamma.all <- glm(BA  ~ TREAT + SITE + SLOPE + scale(SOLAR) + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
mD_BA.gamma.slope <- glm(BA  ~ TREAT + SITE + SLOPE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
mD_BA.gamma.solar <- glm(BA  ~ TREAT + SITE + scale(SOLAR) + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
par(mfrow=c(4,4))
plot(mD_BA.gamma, main= "Gamma")
plot(mD_BA.gamma.all, main="All covariates")
plot(mD_BA.gamma.slope, main="Slope")
plot(mD_BA.gamma.solar, main="Solar")
summary(mD_BA.gamma.solar)
summary(mD_BA.gamma.slope)
summary(mD_BA.gamma.all)
summary(mD_BA.gamma)
mC_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  + scale(SOLAR) + (TREAT*SITE), link = log, data = CONIF_dens)
summary(mC_D.nb.solar)
summary(mC_D.nb.slope) #AIC 926
summary(mC_D.nb)	#AIC 924
mC_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  + SLOPE +  scale(SOLAR) + (TREAT*SITE), link = log, data = CONIF_dens)
summary(mC_D.nb.both)
mC_D.nb.both <- 	glm.nb(COUNT ~ TREAT + SITE  + SLOPE +  scale(SOLAR) + (TREAT*SITE), link = log, data = CONIF_dens)
summary(mC_D.nb.both)
mC_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + scale(SLOPE)  + (TREAT*SITE),link = log, data = CONIF_dens)
summary(mC_D.nb.slope) #AIC 926
mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + scale(SOLAR) + (TREAT*SITE),link = log,
data = DECID_dens)
summary(mD_D.nb.all) # AIC 1080
library(tidyverse)
library(cowplot)
library(here)
theme_set(theme_cowplot())
options(scipen = 9999)
se <- function(x) sqrt(var(x)/length(x))
library(sjPlot)
library(MASS)
library(parameters)
library(logNormReg)
# getting values
dens <- read.csv(here("density.csv"))
# getting values
dens <- read.csv(here("data/density.csv"))
treat_dens <- dens %>%
group_by(SITE, TREAT, DIV) %>%
summarise(AV = mean(COUNT_HA), SE = se(COUNT_HA))
View(treat_dens)
treat_dens$SE <- round(treat_dens$SE, digits = 0)
treat_dens$AV <- round(treat_dens$AV, digits = 0)
treat_dens %>%
filter(SITE == "DALTON") %>%
filter(DIV == "c")
treat_dens %>%
filter(SITE == "DALTON") %>%
filter(DIV == "d")
50592/308
50592/22658
22658/11872
treat_dens %>%
filter(SITE == "STEESE") %>%
filter(DIV == "d")
11344/58
32126/11344
11344/59
32126/19742
# getting values
ba <- read_csv(here("ba.csv"))
treat_ba <- ba %>%
group_by(SITE, TREAT, DIV) %>%
summarise(AV = mean(BA_SUM), SE = se(BA_SUM))
treat_ba <- ba %>%
group_by(SITE, TREAT, DIV) %>%
summarise(AV = mean(BA_ha), SE = se(BA_ha))
treat_ba$SE <- round(treat_ba$SE, digits = 1)
treat_ba$AV <- round(treat_ba$AV, digits = 1)
treat_ba %>%
filter(SITE == "DALTON") %>%
filter(DIV == "d")
treat_ba %>%
filter(SITE == "STEESE") %>%
filter(DIV == "d")
View(ba)
View(treat_ba)
View(ba)
treat_ba <- ba %>%
group_by(SITE, TREAT, DIV) %>%
summarise(AV = mean(BA_ha), SE = se(BA_ha))
treat_ba %>%
filter(SITE == "DALTON") %>%
filter(DIV == "d")
0.23342702/0.00974961
treat_ba %>%
filter(SITE == "STEESE") %>%
filter(DIV == "d")
0.111337093/0.00533668
treat_ba %>%
filter(SITE == "DALTON") %>%
filter(DIV == "d")
0.1421507/0.00974961
treat_ba %>%
filter(SITE == "STEESE") %>%
filter(DIV == "d")
0.005383468/0.003336479/
0.005383468/0.003336479
0.007453202/0.003336479
treat_ba %>%
filter(SITE == "DALTON") %>%
filter(DIV == "d")
0.02849430/0.01421507
library(tidyverse)
library(MASS)
library(here)
library(parameters)
library(logNormReg)
library(cowplot); theme_set(theme_cowplot())
# bringing in data
dens <- read.csv(here("data/density.csv"))
# removing unburned sites
dens <- dens[dens$TREAT !=0,]
dens$TREAT <- as.factor(dens$TREAT)
# looking at format of data, first three rows
dens[1:3,]
#Different way of subsetting, base R
CONIF_dens <- subset(dens, dens$DIV == "c")
#the plots are duplicated with one entry per conifer species, so this reduces it to one value per plot
cnt <- aggregate(CONIF_dens$COUNT_HA, list(CONIF_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
trt <- aggregate(CONIF_dens$TREAT, list(CONIF_dens$PLOT), FUN = mean)	#gets the treatment number (mean works because they are the same
CONIF_dens_new <- cbind(cnt, trt[,2])						#combines
temp <- merge(x=CONIF_dens_new, y=CONIF_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
CONIF_dens_new <- temp[duplicated(temp[,1]),]					#merging and removing
CONIF_dens <- CONIF_dens_new %>%
rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use
hist(CONIF_dens$COUNT)									#check
library(tidyverse)
library(cowplot)
library(here)
theme_set(theme_cowplot())
options(scipen = 9999)
se <- function(x) sqrt(var(x)/length(x))
library(sjPlot)
library(MASS)
library(logNormReg)
dens <- read.csv(here("data/density.csv"))
# removing unburned sites
dens <- dens[dens$TREAT !=0,]
dens$TREAT <- as.factor(dens$TREAT)
# looking at format of data, first three rows
dens[1:3,]
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned sites used here
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in dens
order <- as.vector(unique(dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order)) %>% # matches the same order of plots as density file
slice(rep(1:n(), each = 8)) # replicates each value by 8, since there's 8 rows per plot (8 species)
# adding in attributes to density file
dens$SLOPE <- attrib$SLOPE
dens$ELEV <- attrib$ELEVATION
dens$SOLAR <- attrib$SOLAR
dens <- read.csv(here("data/density.csv"))
# removing unburned sites
dens <- dens[dens$TREAT !=0,]
# looking at format of data, first three rows
dens[1:3,]
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned sites used here
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in dens
order <- as.vector(unique(dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order)) %>% # matches the same order of plots as density file
slice(rep(1:n(), each = 8)) # replicates each value by 8, since there's 8 rows per plot (8 species)
# adding in attributes to density file
dens$SLOPE <- attrib$SLOPE
dens$ELEV <- attrib$ELEVATION
dens$SOLAR <- attrib$SOLAR
hist(CONIF_dens$COUNT)									#check
mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
View(CONIF_dens)
View(CONIF_dens_new)
# Different way of subsetting, base R
CONIF_dens <- subset(dens, dens$DIV == "c")
#the plots are duplicated with one entry per conifer species, so this reduces it to one value per plot
cnt <- aggregate(CONIF_dens$COUNT_HA, list(CONIF_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
trt <- aggregate(CONIF_dens$TREAT, list(CONIF_dens$PLOT), FUN = mean)	#gets the treatment number (mean works because they are the same
CONIF_dens_new <- cbind(cnt, trt[,2])						#combines
temp <- merge(x=CONIF_dens_new, y=CONIF_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
CONIF_dens_new <- temp[duplicated(temp[,1]),]					#merging and removing
CONIF_dens <- CONIF_dens_new %>%
rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use
hist(CONIF_dens$COUNT)
mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
mC_D    <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = CONIF_dens)
mC_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = CONIF_dens)
# residuals
par(mfrow=c(3,4))
plot(mC_D, main="Poisson")
plot(mC_D_qp, main="Quasi-poisson")
plot(mC_D.nb, main="NB")
summary(mC_D)
summary(mC_D_qp)
summary(mC_D.nb) # AIC 924.43
summary(mC_D_qp)
# parameters
summary(mC_D)
mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
mC_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),
link = log, data = CONIF_dens)
summary(mC_D.nb)
summary(mC_D.nb.slope) # AIC
DECID_dens <- subset(dens, dens$DIV == "d")
# the plots are duplicated with one entry per species, so this reduces it to one value per plot
cnt <- aggregate(DECID_dens$COUNT_HA, list(DECID_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
trt <- aggregate(DECID_dens$TREAT, list(DECID_dens$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
DECID_dens_new <- cbind(cnt, trt[,2])						#combines
temp <- merge(x=DECID_dens_new, y=DECID_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
temp2 <- temp[duplicated(temp[,1]),]										#merging and removing
temp3 <- temp2[duplicated(temp2[,1]),]        # have to loop through, since there's so many more species
temp4 <- temp3[duplicated(temp3[,1]),]        # absolutely sure there's a faster way to do this, just wanted to get it done
temp5 <- temp4[duplicated(temp4[,1]),]
DECID_dens_new <- temp5[duplicated(temp5[,1]),]
rm(temp,temp2, temp3, temp4, temp5, cnt, trt) 				# cleaning up workspace
DECID_dens <- DECID_dens_new %>%
rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use							#back to original name so code below works
hist(DECID_dens$COUNT)
dev.off()
hist(DECID_dens$COUNT)									#check
mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
mD_D <- 		glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = DECID_dens)
mD_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = DECID_dens)
# parameters
summary(mD_D)
summary(mD_D_qp)
summary(mD_D.nb)
#bringing in other covariates
#adding them into the glm above
mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
mD_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = DECID_dens)
summary(mD_D.nb)
summary(mD_D.nb.slope)
# bringing in data
ba <- read.csv(("ba.csv"), stringsAsFactors = F)
# removing unburned sites
ba <- ba[ba$TREAT != 0,]
ba$TREAT <- as.factor(ba$TREAT)
ba$TREAT <- as.factor(ba$TREAT)
# looking at format of data, first three rows
ba[1:3,]
DECID_BA <- subset(ba, ba$DIV == "d")
DECID_BA$QUAD[DECID_BA$QUAD == 2] <- 50	#assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
DECID_BA$QUAD[DECID_BA$QUAD == 1] <- 100
DECID_BA$QUAD[DECID_BA$QUAD == .1] <- 1000
DECID_BA$QUAD[DECID_BA$QUAD == .2] <- 500
#calc basal area
DECID_BA$BA <- (pi * (DECID_BA$DBH/2)^2)/10000	#convert to ba and cm2 to m2. Just pi*r2
DECID_BA$BA_ha <- DECID_BA$BA * DECID_BA$QUAD		#multiply by expansion factor
ba.plot <- aggregate(DECID_BA$BA_ha, list(DECID_BA$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
ba.trt <- aggregate(DECID_BA$TREAT, list(DECID_BA$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
test <- DECID_BA %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(BA = sum(BA_HA))
ba <- read.csv(("ba.csv"), stringsAsFactors = F)
# removing unburned sites
ba <- ba[ba$TREAT != 0,]
# looking at format of data, first three rows
ba[1:3,]
DECID_BA <- subset(ba, ba$DIV == "d")
DECID_BA$QUAD[DECID_BA$QUAD == 2] <- 50	#assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
DECID_BA$QUAD[DECID_BA$QUAD == 1] <- 100
DECID_BA$QUAD[DECID_BA$QUAD == .1] <- 1000
DECID_BA$QUAD[DECID_BA$QUAD == .2] <- 500
#calc basal area
DECID_BA$BA <- (pi * (DECID_BA$DBH/2)^2)/10000	#convert to ba and cm2 to m2. Just pi*r2
DECID_BA$BA_ha <- DECID_BA$BA * DECID_BA$QUAD		#multiply by expansion factor
test <- DECID_BA %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(BA = sum(BA_HA))
test <- DECID_BA %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(BA = sum(BA_ha))
View(test)
View(CONIF_dens)
ba <- read.csv(("ba.csv"), stringsAsFactors = F)
# removing unburned sites
ba <- ba[ba$TREAT != 0,]
# looking at format of data, first three rows
ba[1:3,]
########################
## deciduous basal area
DECID_BA <- subset(ba, ba$DIV == "d")
DECID_BA$QUAD[DECID_BA$QUAD == 2] <- 50	#assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
DECID_BA$QUAD[DECID_BA$QUAD == 1] <- 100
DECID_BA$QUAD[DECID_BA$QUAD == .1] <- 1000
DECID_BA$QUAD[DECID_BA$QUAD == .2] <- 500
#calc basal area
DECID_BA$BA <- (pi * (DECID_BA$DBH/2)^2)/10000	#convert to ba and cm2 to m2. Just pi*r2
DECID_BA$BA_ha <- DECID_BA$BA * DECID_BA$QUAD		#multiply by expansion factor
#a single line, does the same thing (calculates basal area and scales by expansion factor):
#DECID_BA$BA_ha <- DECID_BA$DBH^2*0.00007854*DECID_BA$QUAD  #note this does the same thing, just simplified algebraically
ba.plot <- aggregate(DECID_BA$BA_ha, list(DECID_BA$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
ba.trt <- aggregate(DECID_BA$TREAT, list(DECID_BA$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
DECID_ba_new <- cbind(ba.plot, ba.trt[,2])						#combines
names(DECID_ba_new) <- c("PLOT","BA","TREAT")
ba.site <- cbind(DECID_BA$SITE,DECID_BA$PLOT)
temp <- as.data.frame(ba.site[!duplicated(ba.site[,2]),])
names(temp) <- c("SITE","PLOT")
DECID_BA <- merge(DECID_ba_new,temp,by="PLOT")	#double check all is well with the rows - right site/treatment/value
#histogram
hist(DECID_BA$BA)
ba$TREAT <- as.factor(ba$TREAT)
DECID_BA$TREAT <- as.factor(DECID_BA$TREAT)
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in BA
order <- as.vector(DECID_BA$PLOT) # don't worry that its 42, remember this doesnt include unburned
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order))
# adding in attributes to density file
DECID_BA$SLOPE <- attrib$SLOPE
DECID_BA$ELEV <- attrib$ELEVATION
DECID_BA$SOLAR <- attrib$SOLAR
mD_BA.log <- lm(log(BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)						#models E[log(y)]
mD_BA.ga <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = gaussian(link = "log"), data = DECID_BA)	#models log[E(y)]
mD_BA.gamma <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
#another option, look up lognormal distributions
BA_logn <- lognlm((BA)  ~ TREAT + SITE + (TREAT*SITE), data = DECID_BA)
# parameters
summary(mD_BA.log)
DECID_ba_new <- cbind(ba.plot, ba.trt[,2])						#combines
summary(mD_BA.ga) # AIC 133
summary(mD_BA.gamma) # AIC 64
summary(BA_logn)
sqrt(mean(mD_BA.log$residuals^2)) # 0.96
sqrt(mean(mD_BA.ga$residuals^2)) # 1.77
sqrt(mean(mD_BA.gamma$residuals^2)) # 0.79
sqrt(mean(BA_logn$residuals^2)) # 1.2
mD_BA.ga <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = gaussian(link = "log"), data = DECID_BA)	#models log[E(y)]
summary(mD_BA.ga) # AIC 133
summary(mD_BA.gamma) # AIC 58
sqrt(mean(mD_BA.ga$residuals^2)) # 0.819
sqrt(mean(BA_logn$residuals^2)) # 1.04
sqrt(mean(mD_BA.gamma$residuals^2)) # 0
# adding in covariates
mD_BA.gamma <- glm(BA  ~ TREAT + SITE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
mD_BA.gamma.slope <- glm(BA  ~ TREAT + SITE + SLOPE + (TREAT*SITE), family = Gamma(link = "log"), data = DECID_BA)
summary(mD_BA.gamma) # AIC 64
summary(mD_BA.gamma.slope) # AIC 62
summary(mD_BA.gamma) # AIC 58.

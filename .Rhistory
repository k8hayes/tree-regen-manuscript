distinct() # creates file where each row is a plot, maintains expansion factors/site/treat
test$SPP <- as.factor("PIGL") # adds species
test$COUNT_ha <- 0 # adds zero count
test$COUNT_PLOT <- 0
test$DIV <- as.factor("c")
dens <- rbind(dens, test) # puts back into dbh file
dens <- dens %>%
group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) %>%
rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
TREE_EXP_FACT = EXP_FACT) # renames tree counts so we can combine with seedling
# combining files
dens$SEED_COUNT_PLOT <- seed$TOTAL_COUNT
dens$SEED_COUNT_HA <- seed$COUNT_ha
dens$SEED_EXP_FACT <- seed$EXP_FACT
# making sure number of fires is a factor
dens$TREAT <- as.factor(dens$TREAT)
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
dens$SEED_COUNT_HA <- seed$COUNT_ha
dens$SEED_EXP_FACT <- seed$EXP_FACT
# making sure number of fires is a factor
dens$TREAT <- as.factor(dens$TREAT)
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
dens <- dens %>%
group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) %>%
rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
TREE_EXP_FACT = EXP_FACT) %>%
ungroup()# renames tree counts so we can combine with seedling
dbh <- read.csv(here("data/dbh.csv"))
dbh$TREAT <- as.factor(dbh$TREAT)
# dropping dead trees
dbh <- dbh %>%
filter(CANOPY > 0)
# summing according to species
dens <- dbh %>%
group_by(SITE, TREAT, PLOT, SPP) %>%
summarise(COUNT_PLOT = n()) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), SPP, fill = list(COUNT_PLOT = 0)) # adds zero-counts back in for species
# adding divisions back in
dens$DIV <- NA
dens$DIV[dens$SPP == "PIME"] <- "c"
dens$DIV[dens$SPP == "BENE"] <- "d"
dens$DIV[dens$SPP == "POTR"] <- "d"
dens$DIV[dens$SPP == "POBA"] <- "d"
dens$DIV[dens$SPP == "SALIX"] <- "d"
dens$DIV[dens$SPP == "ARCTO"] <- "d"
dens$DIV[dens$SPP == "ALCR"] <- "d"
dens$DIV <- as.factor(dens$DIV)
# adding expansion factor back
test <- dbh %>%
group_by(SITE, TREAT, PLOT) %>%
summarise(EXP_FACT = max(EXP_FACT)) %>%
slice(rep(1:n(), each = 7)) %>% # 7 species at each plot, so each plot is 7 rows
ungroup()
dens$EXP_FACT <- test$EXP_FACT # adding expansion factors back in
# scaling up
dens$COUNT_ha <- dens$COUNT_PLOT * dens$EXP_FACT
rm(test, dbh)
seed <- read.csv(here("data/seedling_count_raw.csv"))
# adding expansion factors
seed$EXP_FACT <- NA
seed$EXP_FACT[seed$M2 == 100] <- 100
seed$EXP_FACT[seed$M2 == 10] <- 1000
seed$EXP_FACT[seed$M2 == 20] <- 500
seed$EXP_FACT[seed$M2 == 9] <- (10000/9)
# scaling up
seed$COUNT_ha <- seed$EXP_FACT * seed$TOTAL_COUNT
# combining seedling and dbh
seed <- seed %>%
group_by(SITE, TREAT, PLOT) %>%
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) # arranges species in the same order within plots
# also orders plots in same order within sites
# need to do to combine with dbh in a sec
# creating PIGL rows
# no white spruce at dbh height on plots, but need to add to combine with seedling file
test <- dens %>%
dplyr::select(SITE, TREAT, PLOT, EXP_FACT) %>% # need the dplyr because MASS package conflicts with select()
distinct() # creates file where each row is a plot, maintains expansion factors/site/treat
test$SPP <- as.factor("PIGL") # adds species
test$COUNT_ha <- 0 # adds zero count
test$COUNT_PLOT <- 0
test$DIV <- as.factor("c")
dens <- rbind(dens, test) # puts back into dbh file
dens <- dens %>%
group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) %>%
rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
TREE_EXP_FACT = EXP_FACT) %>%
ungroup()# renames tree counts so we can combine with seedling
# combining files
dens$SEED_COUNT_PLOT <- seed$TOTAL_COUNT
dens$SEED_COUNT_HA <- seed$COUNT_ha
dens$SEED_EXP_FACT <- seed$EXP_FACT
# making sure number of fires is a factor
dens$TREAT <- as.factor(dens$TREAT)
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
#  write.csv(dens, here("data/density.csv"), row.names = F)
rm(test, seed)
dbh <- read.csv(here("data/dbh.csv"))
dbh$TREAT <- as.factor(dbh$TREAT)
# dropping dead trees
dbh <- dbh %>%
filter(CANOPY > 0)
# summing according to species
dens <- dbh %>%
group_by(SITE, TREAT, PLOT, SPP) %>%
summarise(COUNT_PLOT = n()) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), SPP, fill = list(COUNT_PLOT = 0)) # adds zero-counts back in for species
# adding divisions back in
dens$DIV <- NA
dens$DIV[dens$SPP == "PIME"] <- "c"
dens$DIV[dens$SPP == "BENE"] <- "d"
dens$DIV[dens$SPP == "POTR"] <- "d"
dens$DIV[dens$SPP == "POBA"] <- "d"
dens$DIV[dens$SPP == "SALIX"] <- "d"
dens$DIV[dens$SPP == "ARCTO"] <- "d"
dens$DIV[dens$SPP == "ALCR"] <- "d"
dens$DIV <- as.factor(dens$DIV)
# adding expansion factor back
test <- dbh %>%
group_by(SITE, TREAT, PLOT) %>%
summarise(EXP_FACT = max(EXP_FACT)) %>%
slice(rep(1:n(), each = 7)) %>% # 7 species at each plot, so each plot is 7 rows
ungroup()
dens$EXP_FACT <- test$EXP_FACT # adding expansion factors back in
# scaling up
dens$COUNT_ha <- dens$COUNT_PLOT * dens$EXP_FACT
rm(test, dbh)
seed <- read.csv(here("data/seedling_count_raw.csv"))
# adding expansion factors
seed$EXP_FACT <- NA
seed$EXP_FACT[seed$M2 == 100] <- 100
seed$EXP_FACT[seed$M2 == 10] <- 1000
seed$EXP_FACT[seed$M2 == 20] <- 500
seed$EXP_FACT[seed$M2 == 9] <- (10000/9)
# scaling up
seed$COUNT_ha <- seed$EXP_FACT * seed$TOTAL_COUNT
# combining seedling and dbh
seed <- seed %>%
group_by(SITE, TREAT, PLOT) %>%
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) # arranges species in the same order within plots
# also orders plots in same order within sites
# need to do to combine with dbh in a sec
# creating PIGL rows
# no white spruce at dbh height on plots, but need to add to combine with seedling file
test <- dens %>%
dplyr::select(SITE, TREAT, PLOT, EXP_FACT) %>% # need the dplyr because MASS package conflicts with select()
distinct() # creates file where each row is a plot, maintains expansion factors/site/treat
test$SPP <- as.factor("PIGL") # adds species
test$COUNT_ha <- 0 # adds zero count
test$COUNT_PLOT <- 0
test$DIV <- as.factor("c")
dens <- rbind(dens, test) # puts back into dbh file
dens <- dens %>%
group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) %>%
rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
TREE_EXP_FACT = EXP_FACT) %>%
ungroup()# renames tree counts so we can combine with seedling
# combining files
dens$SEED_COUNT_PLOT <- seed$TOTAL_COUNT
dens$SEED_COUNT_HA <- seed$COUNT_ha
dens$SEED_EXP_FACT <- seed$EXP_FACT
# making sure number of fires is a factor
dens$TREAT <- as.factor(dens$TREAT)
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
#  write.csv(dens, here("data/density.csv"), row.names = F)
rm(test, seed)
# removing unburned sites
dens <- dens[dens$TREAT !=0,]
dens$TREAT <- as.factor(dens$TREAT)
# looking at format of data, first three rows
dens[1:3,]
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned sites used here
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in dens
order <- as.vector(unique(dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order)) %>% # matches the same order of plots as density file
slice(rep(1:n(), each = 8)) # replicates each value by 8, since there's 8 rows per plot (8 species)
# adding in attributes to density file
dens$SLOPE <- attrib$SLOPE
dens$ELEV <- attrib$ELEVATION
dens$SOLAR <- attrib$SOLAR
rm(attrib)
dens$TREAT <- as.factor(dens$TREAT) # just to make sure
# subsetting to conifers
CONIF_dens <- subset(dens, dens$DIV == "c")
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), SPP, fill = list(COUNT_HA = 0))
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0))
View(test)
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0))
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
dplyr::select(DIV == "c")
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
ungroup() %>%
dplyr::select(DIV == "c")
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0))
test <- test %>%
dplyr::select(DIV == "c")
test <- test %>%
dplyr::select(DIV == "c")
test <- test %>%
filter(DIV == "c")
View(CONIF_dens)
View(CONIF_dens_new)
View(CONIF_dens)
hist(CONIF_dens$COUNT)									#check
CONIF_dens <- subset(dens, dens$DIV == "c")
#the plots are duplicated with one entry per conifer species, so this reduces it to one value per plot
cnt <- aggregate(CONIF_dens$COUNT_HA, list(CONIF_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
trt <- aggregate(CONIF_dens$TREAT, list(CONIF_dens$PLOT), FUN = mean)	#gets the treatment number (mean works because they are the same
CONIF_dens_new <- cbind(cnt, trt[,2])						#combines
temp <- merge(x=CONIF_dens_new, y=CONIF_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
CONIF_dens_new <- temp[duplicated(temp[,1]),]					#merging and removing
CONIF_dens <- CONIF_dens_new %>%
rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use
View(CONIF_dens)
# checking test
# getting order of sites in dens
order <- as.vector(unique(CONIF_dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
test <- test %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order))
test <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
filter(DIV == "c")
hist(CONIF_dens$COUNT)									#check
# getting order of sites in dens
order <- as.vector(unique(CONIF_dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
test <- test %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order))
CONIF_dens <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
filter(DIV == "c")
DECID_dens <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT_HA = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
filter(DIV == "d")
rm(cnt, CONIF_dens_new, trt, temp)
install.packages(sjPlot)
install.packages('sjPLOT')
install.packages('sjPlot')
install.packages("logNormReg")
hist(CONIF_dens$COUNT_HA)									#check
#useful helper package
library(doBy)
#replicable
set.seed(100)
#data frame - note that because we are setting the values we know the exact SE
dd <- data.frame(
group = c(rep("group1", 100),rep("group2", 100)),
values = c(rpois(n=100, lambda=2), rpois(n=100, lambda=7))
)
#quick calculation
logmean <- function(x){
log(mean(x))
}
#quick summary stats for comparsion
ss <- summaryBy(values ~ group, data=dd,
FUN=c(length, logmean, mean, var, sd)
)
#calculating SE normal way (note incorrect given this is a Poisson generated process)
ss$SE.normal <- sqrt(ss$values.var/(ss$values.length-1))
#calculate SE for a poisson process
ss$sd.Poiss <- sqrt(ss$values.mean)
ss$se.Poiss <- sqrt(ss$values.mean/ss$values.length)
#organize
ss <- cbind(ss[,"group"], round(ss[,-1],3))
names(ss) <- c("group", "N", "log.mean", "mean", "variance", "sd", "SE","sd.Poiss","se.Poiss")
glm1 <- glm(values ~ group, data=dd, family="poisson"(link = "log"))
#OK, so this is like your data
summary(glm1)
#now predict new data, but the response, which will back transform
preddata <- data.frame(group=unique(dd$group))
preds <- predict(glm1, newdata=preddata, type="response", se.fit=T)
View(preds)
View(preddata)
#note the evidence it's back transformed proper
preds$fit; ss$mean
#and the se is calculated back OK
preds$se.fit; ss$se.Poiss
# Confidence interval (95)
fit <- preds$fit
lwr <- fit - 1.96*preds$se.fit
upr <- fit + 1.96*preds$se.fit
library(tidyverse)
library(cowplot)
library(here)
theme_set(theme_cowplot())
options(scipen = 9999)
se <- function(x) sqrt(var(x)/length(x))
library(sjPlot)
library(MASS)
library(logNormReg)
dbh <- read.csv(here("data/dbh.csv"))
dbh$TREAT <- as.factor(dbh$TREAT)
# dropping dead trees
dbh <- dbh %>%
filter(CANOPY > 0)
# summing according to species
dens <- dbh %>%
group_by(SITE, TREAT, PLOT, SPP) %>%
summarise(COUNT_PLOT = n()) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), SPP, fill = list(COUNT_PLOT = 0)) # adds zero-counts back in for species
# adding divisions back in
dens$DIV <- NA
dens$DIV[dens$SPP == "PIME"] <- "c"
dens$DIV[dens$SPP == "BENE"] <- "d"
dens$DIV[dens$SPP == "POTR"] <- "d"
dens$DIV[dens$SPP == "POBA"] <- "d"
dens$DIV[dens$SPP == "SALIX"] <- "d"
dens$DIV[dens$SPP == "ARCTO"] <- "d"
dens$DIV[dens$SPP == "ALCR"] <- "d"
dens$DIV <- as.factor(dens$DIV)
# adding expansion factor back
test <- dbh %>%
group_by(SITE, TREAT, PLOT) %>%
summarise(EXP_FACT = max(EXP_FACT)) %>%
slice(rep(1:n(), each = 7)) %>% # 7 species at each plot, so each plot is 7 rows
ungroup()
dens$EXP_FACT <- test$EXP_FACT # adding expansion factors back in
# scaling up
dens$COUNT_ha <- dens$COUNT_PLOT * dens$EXP_FACT
rm(test, dbh)
seed <- read.csv(here("data/seedling_count_raw.csv"))
# adding expansion factors
seed$EXP_FACT <- NA
seed$EXP_FACT[seed$M2 == 100] <- 100
seed$EXP_FACT[seed$M2 == 10] <- 1000
seed$EXP_FACT[seed$M2 == 20] <- 500
seed$EXP_FACT[seed$M2 == 9] <- (10000/9)
# scaling up
seed$COUNT_ha <- seed$EXP_FACT * seed$TOTAL_COUNT
# combining seedling and dbh
seed <- seed %>%
group_by(SITE, TREAT, PLOT) %>%
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) # arranges species in the same order within plots
# also orders plots in same order within sites
# need to do to combine with dbh in a sec
# creating PIGL rows
# no white spruce at dbh height on plots, but need to add to combine with seedling file
test <- dens %>%
dplyr::select(SITE, TREAT, PLOT, EXP_FACT) %>% # need the dplyr because MASS package conflicts with select()
distinct() # creates file where each row is a plot, maintains expansion factors/site/treat
test$SPP <- as.factor("PIGL") # adds species
test$COUNT_ha <- 0 # adds zero count
test$COUNT_PLOT <- 0
test$DIV <- as.factor("c")
dens <- rbind(dens, test) # puts back into dbh file
dens <- dens %>%
group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
.by_group = T) %>%
rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
TREE_EXP_FACT = EXP_FACT) %>%
ungroup()# renames tree counts so we can combine with seedling
# combining files
dens$SEED_COUNT_PLOT <- seed$TOTAL_COUNT
dens$SEED_COUNT_HA <- seed$COUNT_ha
dens$SEED_EXP_FACT <- seed$EXP_FACT
# making sure number of fires is a factor
dens$TREAT <- as.factor(dens$TREAT)
# creating total count of both trees and seedlings
dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
#  write.csv(dens, here("data/density.csv"), row.names = F)
rm(test, seed)
# removing unburned sites
dens <- dens[dens$TREAT !=0,]
dens$TREAT <- as.factor(dens$TREAT)
# looking at format of data, first three rows
dens[1:3,]
# pulling in site attribute variables
attrib <- read.csv(here("data/site_attrib.csv"))
# no unburned sites used here
attrib <-attrib[attrib$TREAT != 0,]
# getting order of sites in dens
order <- as.vector(unique(dens$PLOT)) # don't worry that its 42, remember this doesn't include unburned sites
attrib <- attrib %>%
group_by(SITE, TREAT) %>%
arrange(match(PLOT,order)) %>% # matches the same order of plots as density file
slice(rep(1:n(), each = 8)) # replicates each value by 8, since there's 8 rows per plot (8 species)
# adding in attributes to density file
dens$SLOPE <- attrib$SLOPE
dens$ELEV <- attrib$ELEVATION
dens$SOLAR <- attrib$SOLAR
rm(attrib)
dens$TREAT <- as.factor(dens$TREAT) # just to make sure
CONIF_dens <- dens %>%
group_by(SITE, TREAT, PLOT, DIV) %>%
summarise(COUNT = sum(COUNT_HA), SLOPE = first(SLOPE)) %>%
ungroup() %>%
complete(nesting(SITE, TREAT, PLOT), DIV, fill = list(COUNT_HA = 0)) %>%
filter(DIV == "c")
CONIF_dens$TREAT <- as.factor(CONIF_dens$TREAT) #
CONIF_dens$TREAT <- as.factor(CONIF_dens$TREAT)
mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
mC_D    <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = CONIF_dens)
mC_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = CONIF_dens)
# residuals
par(mfrow=c(3,4))
plot(mC_D, main="Poisson")
plot(mC_D_qp, main="Quasi-poisson")
plot(mC_D.nb, main="NB")
# parameters
summary(mC_D)
summary(mC_D_qp)
summary(mC_D.nb) # AIC 924
#note the prediction vs. observed isn't great, but that's not the point here
dev.off()
plot(predict(mC_D.nb, type="response",se.fit=T)$fit,CONIF_dens$COUNT)	#plots the exponentiated prediction back
abline(0,1, col="red")								#one to one line
plot(predict(mC_D.nb, type="response",se.fit=T)$fit, predict(mC_D.nb, type="response",se.fit=T)$se.fit, ylab="SE", xlab="Prediction")
abline(0,1, col="red")
#to do so, adding them into the glm above, but then check the diagnostics again of course
mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
mC_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),
link = log, data = CONIF_dens)
par(mfrow=c(2,4))
plot(mC_D.nb, main="NB")
plot(mC_D.nb.slope, main="Slope")
summary(mC_D.nb) # AIC 924
summary(mC_D.nb.slope) # AIC 926
round(confint(mC_D.nb), digits = 2)
sqrt(mean(mC_D.nb$residuals^2))
sqrt(mean(mC_D.nb.slope$residuals^2))
#data frame - note that because we are setting the values we know the exact SE
dd <- data.frame(
group = c(rep("group1", 100),rep("group2", 100)),
values = c(rpois(n=100, lambda=2), rpois(n=100, lambda=7))
)
ss
preds$fit
#note the evidence it's back transformed proper
preds$fit; ss$mean
#now predict new data, but the response, which will back transform
preddata <- data.frame(group=unique(CONIF_dens$group))
View(dd)
#now predict new data, but the response, which will back transform
preddata <- data.frame(group=unique(CONIF_dens$TREAT))
preds <- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)
#now predict new data, but the response, which will back transform
preddata <- data.frame(group=unique(CONIF_dens$PLOT))
preds <- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)
#note the evidence it's back transformed proper
preds$fit; ss$mean
#note the evidence it's back transformed proper
preds$fit
preds <- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)
#now predict new data, but the response, which will back transform
preddata <- data.frame(PLOT=unique(CONIF_dens$PLOT))
preds <- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)
#now predict new data, but the response, which will back transform
preddata <- data.frame(PLOT=unique(CONIF_dens$PLOT))
preds<- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)
#now predict new data, but the response, which will back transform
preddata <- data.frame(TREAT = unique(CONIF_dens$TREAT))
preds<- predict(mC_D.nb, newdata=preddata, type="response", se.fit=T)

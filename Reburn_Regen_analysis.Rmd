---
title: "Reburns_Regen_analysis"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(cowplot)
library(here)
theme_set(theme_cowplot())
options(scipen = 9999)
se <- function(x) sqrt(var(x)/length(x))

library(sjPlot)
library(MASS)
library(parameters)
library(logNormReg)
```

## R Markdown


## Density data set

Code cleans up DBH, adds division (conifer / deciduous) to species, adds expansion factors specific to each plot (both dbh and seedlings were counted across different subsamples for each plot, so scaling to ha is a bit more complicated).

```{r clean up of dbh data}
# dbh <- read.csv(here("data/dbh_raw.csv"))
# 
#   # merging salix
#   dbh$SPP[dbh$SPP == "SAGL"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_3"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_4"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_5"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_6"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_7"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_8"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SA_?"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SADE"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SAPU"] <- "SALIX"
#   dbh$SPP[dbh$SPP == "SAGL_R"] <- "SALIX"
#   
#    # dropping unknown
#      dbh <- dbh %>%
#        filter(SPP != "UNKNOWN")
#   
#  # adding conifer and deciduous divisons
#     dbh$DIV[dbh$SPP == "PIME"] <- "c"
#     dbh$DIV[dbh$SPP == "BENE"] <- "d"
#     dbh$DIV[dbh$SPP == "POTR"] <- "d"
#     dbh$DIV[dbh$SPP == "POBA"] <- "d"
#     dbh$DIV[dbh$SPP == "SALIX"] <- "d"
#     dbh$DIV[dbh$SPP == "ARCTO"] <- "d"
#     dbh$DIV[dbh$SPP == "ALCR"] <- "d"
# 
# # adding expansion factors
#     # assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
#   dbh$EXP_FACT[dbh$QUAD == 2] <- 50
#   dbh$EXP_FACT[dbh$QUAD == 1] <- 100
#   dbh$EXP_FACT[dbh$QUAD == .1] <- 1000
#   dbh$EXP_FACT[dbh$QUAD == .2] <- 500
# 
#  write.csv(dbh, here("data/dbh.csv"), row.names = F)
```

```{r dbh sum, expansion factors and divisions}
dbh <- read.csv(here("data/dbh.csv"))
dbh$TREAT <- as.factor(dbh$TREAT)
  # dropping dead trees
    dbh <- dbh %>%
      filter(CANOPY > 0)
  # summing according to species
  dens <- dbh %>%
    group_by(SITE, TREAT, PLOT, SPP) %>%
    summarise(COUNT_PLOT = n()) %>%
    ungroup() %>%
    group_by(SITE, TREAT,PLOT) %>%
    complete( SPP, fill = list(COUNT_PLOT = 0))
  
  # adding divisions back in
    dens$DIV <- NA
    dens$DIV[dens$SPP == "PIME"] <- "c"
    dens$DIV[dens$SPP == "BENE"] <- "d"
    dens$DIV[dens$SPP == "POTR"] <- "d"
    dens$DIV[dens$SPP == "POBA"] <- "d"
    dens$DIV[dens$SPP == "SALIX"] <- "d"
    dens$DIV[dens$SPP == "ARCTO"] <- "d"
    dens$DIV[dens$SPP == "ALCR"] <- "d"
    
  # adding expansion factor back
    test <- dbh %>%
    group_by(SITE, TREAT, PLOT) %>%
    summarise(EXP_FACT = max(EXP_FACT)) %>%
      slice(rep(1:n(), each = 7)) %>%
      ungroup()
  
    dens$EXP_FACT <- test$EXP_FACT

# scaling up
    dens$COUNT_ha <- dens$COUNT_PLOT * dens$EXP_FACT
    
    dens$DIV <- as.factor(dens$DIV)
```

```{r seed sum, expansion fact, divisons and adding with dbh}
seed <- read.csv(here("data/seedling_count_raw.csv"))

# adding expansion factors
  seed$EXP_FACT <- NA
  seed$EXP_FACT[seed$M2 == 100] <- 100
  seed$EXP_FACT[seed$M2 == 10] <- 1000
  seed$EXP_FACT[seed$M2 == 20] <- 500
  seed$EXP_FACT[seed$M2 == 9] <- (10000/9)
  
# scaling up
  seed$COUNT_ha <- seed$EXP_FACT * seed$TOTAL_COUNT
  
# combining seedling and dbh
  seed <- seed %>% 
    group_by(SITE, TREAT, PLOT) %>%
    arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
            .by_group = T) # arranges species in the same order within plots
                           # also orders plots in same order within sites
                           # need to do to combine with dbh in a sec

  # creating PIGL rows 
  # no white spruce at dbh height on plots, but need to add to combine with seedling file
  test <- dens %>%
    dplyr::select(SITE, TREAT, PLOT, EXP_FACT) %>% # need the dplyr because MASS package conflicts with select()
    distinct() # creates file where each row is a plot, maintains expansion factors/site/treat
  test$SPP <- as.factor("PIGL") # adds species
  test$COUNT_ha <- 0 # adds zero count
  test$COUNT_PLOT <- 0
  test$DIV <- as.factor("c")
  dens <- rbind(dens, test) # puts back into dbh file 
  
   dens <- dens %>%
    group_by(SITE, TREAT, PLOT) %>% # same function as above # specifies order of species
    arrange(match(SPP, c("ALCR", "ARCTO", "BENE", "POBA", "POTR", "SALIX", "PIGL", "PIME")),
            .by_group = T) %>%
     rename(TREE_COUNT_PLOT = COUNT_PLOT, TREE_COUNT_HA = COUNT_ha,
            TREE_EXP_FACT = EXP_FACT) # renames tree counts so we can combine with seedling
   
  # combining files
  dens$SEED_COUNT_PLOT <- seed$TOTAL_COUNT
  dens$SEED_COUNT_HA <- seed$COUNT_ha
  dens$SEED_EXP_FACT <- seed$EXP_FACT

  write.csv(dens, here("data/density.csv"), row.names = F)
```

```{r bringing in site attributes as covariates}
dens <- read.csv(here("data/density.csv"))

    # removing unburned sites
    dens <- dens[dens$TREAT !=0,]
    
    # looking at format of data, first three rows
    dens[1:3,]

    # creating count of both trees and seedlings
    dens$COUNT_HA <- dens$TREE_COUNT_HA + dens$SEED_COUNT_HA
    
# pulling in site attribute variables
    attrib <- read.csv(here("data/site_attrib.csv"))
    
    # no unburned
    attrib <-attrib[attrib$TREAT != 0,]
    
    # getting order of sites in dens
    order <- as.vector(unique(dens$PLOT)) # don't worry that its 42, remember this doesnt include unburned
    attrib <- attrib %>%
      group_by(SITE, TREAT) %>%
      arrange(match(PLOT,order)) %>%
      slice(rep(1:n(), each = 8))
    # adding in attributes to density file
    dens$SLOPE <- attrib$SLOPE
    dens$ELEV <- attrib$ELEVATION
    dens$SOLAR <- attrib$SOLAR
    
   write.csv(dens, here("data/density.csv"), row.names = F) 
```

```{r analysis / distribution,}
dens <- read.csv(here("data/density.csv"))

#Different way of subsetting, base R  
  CONIF_dens <- subset(dens, dens$DIV == "c")

#the plots are duplicated with one entry per conifer species, so this reduces it to one value per plot
  cnt <- aggregate(CONIF_dens$COUNT_HA, list(CONIF_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
  trt <- aggregate(CONIF_dens$TREAT, list(CONIF_dens$PLOT), FUN = mean)	#gets the treatment number (mean works because they are the same
  CONIF_dens_new <- cbind(cnt, trt[,2])						#combines
  
  temp <- merge(x=CONIF_dens_new, y=CONIF_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
  CONIF_dens_new <- temp[duplicated(temp[,1]),]					#merging and removing
  CONIF_dens <- CONIF_dens_new %>%	
    rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
    dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use
  hist(CONIF_dens$COUNT)									#check
  
  mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens) 
  mC_D    <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = CONIF_dens)
  mC_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = CONIF_dens) 
  
  # residuals
  par(mfrow=c(3,4))
  plot(mC_D, main="Poisson")
  plot(mC_D_qp, main="Quasi-poisson")
  plot(mC_D.nb, main="NB")
  
  # parameters
  summary(mC_D)
  summary(mC_D_qp)
  summary(mC_D.nb)
  
  model_parameters(mC_D.nb)
  
  #note the prediction vs. observed isn't great, but that's not the point here
  plot(predict(mC_D.nb, type="response",se.fit=T)$fit,CONIF_dens$COUNT)	#plots the exponentiated prediction back
  abline(0,1, col="red")								#one to one line
  
  #the model doesn't do bad at predicting areas with zero trees (treatment effect) are zero, it's the variability
  #in the regen where there is regen (treatments 1 and 2 primarily) that must be explained by other factors.
  #That's clear from this prediction plot and where the major errors are, but also in the standard errors.
  
  plot(predict(mC_D.nb, type="response",se.fit=T)$fit, predict(mC_D.nb, type="response",se.fit=T)$se.fit, ylab="SE", xlab="Prediction")
  abline(0,1, col="red")
  
  #bringing in other covariates

  #to do so, you would add them into the glm above, but then check the diagnostics again of course
    mC_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = CONIF_dens)
    mC_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  +  SOLAR + (TREAT*SITE),link = log, data = CONIF_dens)
    mC_D.nb.elev <- 	glm.nb(COUNT ~ TREAT + SITE  + ELEV + (TREAT*SITE), link = log, data = CONIF_dens)
    mC_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = CONIF_dens)
    mC_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + ELEV + SOLAR + (TREAT*SITE),link = log,
                           data = CONIF_dens)
    
    par(mfrow=c(5,4))
    plot(mC_D.nb, main="NB")
    plot(mC_D.nb.slope, main="Slope")
    plot(mC_D.nb.solar, main= "Solar")
    plot(mC_D.nb.elev, main="Elevation")
    plot(mC_D.nb.all, main = "All")
    
    sqrt(mean(mC_D.nb$residuals^2))
  sqrt(mean(mC_D.nb.slope$residuals^2))
  sqrt(mean(mC_D.nb.elev$residuals^2))
  sqrt(mean(mC_D.nb.solar$residuals^2)) # solar radiation just barely performs best
  sqrt(mean(mC_D.nb.all$residuals^2)) 
  
  # what about combining solar and slope or solar and elevation?
  mC_D.nb.solar.slope <- 	glm.nb(COUNT ~ TREAT + SITE  + SOLAR + SLOPE + (TREAT*SITE),link = log, data = CONIF_dens)
  mC_D.nb.solar.elev <- 	glm.nb(COUNT ~ TREAT + SITE  + ELEV + SOLAR + (TREAT*SITE), link = log, data = CONIF_dens)
  
  sqrt(mean(mC_D.nb$residuals^2))
  sqrt(mean(mC_D.nb.solar$residuals^2)) 
  sqrt(mean(mC_D.nb.solar.slope$residuals^2)) 
  sqrt(mean(mC_D.nb.solar.elev$residuals^2))
  sqrt(mean(mC_D.nb.all$residuals^2)) 
  
  summary(mC_D.nb.all)
  summary(mC_D.nb)
  summary(mC_D.nb.solar)
  summary(mC_D.nb.solar.elev)
  summary(mC_D.nb.solar.slope)
```

```{r deciduous density analysis}
# Different way of subsetting, base R  
  DECID_dens <- subset(dens, dens$DIV == "d")

  # the plots are duplicated with one entry per species, so this reduces it to one value per plot
  cnt <- aggregate(DECID_dens$COUNT_HA, list(DECID_dens$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
  trt <- aggregate(DECID_dens$TREAT, list(DECID_dens$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same
  DECID_dens_new <- cbind(cnt, trt[,2])						#combines
  
  temp <- merge(x=DECID_dens_new, y=DECID_dens, by.x="Group.1", by.y="PLOT", all.x=F, all.y=F)	#adding in the site in a clumsy way but it was quick
  temp2 <- temp[duplicated(temp[,1]),]										#merging and removing
  temp3 <- temp2[duplicated(temp2[,1]),]        # have to loop through, since there's so many more species
  temp4 <- temp3[duplicated(temp3[,1]),]        # absolutely sure there's a faster way to do this, just wanted to get it done
  temp5 <- temp4[duplicated(temp4[,1]),]
  DECID_dens_new <- temp5[duplicated(temp5[,1]),]				
  rm(temp,temp2, temp3, temp4, temp5, cnt, trt) 				# cleaning up workspace
  DECID_dens <- DECID_dens_new %>%	
    rename(PLOT = Group.1, COUNT = x) %>% # renaming columns
    dplyr::select(SITE, TREAT, PLOT, COUNT, SLOPE, ELEV, SOLAR) # selecting only the things we'll use							#back to original name so code below works
  hist(DECID_dens$COUNT)									#check
  
  mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens) 
  mD_D <- 		glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = poisson(link = "log"), data = DECID_dens) 
  mD_D_qp <- 	glm(COUNT ~ TREAT + SITE + (TREAT*SITE), family = quasipoisson(link = "log"), data = DECID_dens) 
  
  # residuals
  par(mfrow=c(3,4))
  plot(mD_D, main="Poisson")
  plot(mD_D_qp, main="Quasi-poisson")
  plot(mD_D.nb, main="NB")
  
  # parameters
  summary(mD_D)
  summary(mD_D_qp)
  summary(mD_D.nb)
  
  model_parameters(mD_D.nb)
  
  
  dev.off()
  plot(predict(mD_D.nb, type="response",se.fit=T)$fit,DECID_dens$COUNT)	#plots the exponentiated prediction back
  abline(0,1, col="red")								#one to one line
  
  plot(predict(mD_D.nb, type="response",se.fit=T)$fit, 
       predict(mD_D.nb, type="response",se.fit=T)$se.fit, ylab="SE", xlab="Prediction")

  #bringing in other covariates
  #adding them into the glm above
  mD_D.nb <- 	glm.nb(COUNT ~ TREAT + SITE + (TREAT*SITE), link = log, data = DECID_dens)
  mD_D.nb.solar <- 	glm.nb(COUNT ~ TREAT + SITE  +  SOLAR + (TREAT*SITE),link = log, data = DECID_dens)
  mD_D.nb.elev <- 	glm.nb(COUNT ~ TREAT + SITE  + ELEV + (TREAT*SITE), link = log, data = DECID_dens)
  mD_D.nb.slope <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE  + (TREAT*SITE),link = log, data = DECID_dens)
  mD_D.nb.all <- 	glm.nb(COUNT ~ TREAT + SITE + SLOPE + ELEV + SOLAR + (TREAT*SITE),link = log,
                         data = DECID_dens)
  
  par(mfrow=c(5,4))
  plot(mD_D.nb, main="NB")
  plot(mD_D.nb.slope, main="Slope")
  plot(mD_D.nb.solar, main= "Solar")
  plot(mD_D.nb.elev, main="Elevation")
  plot(mD_D.nb.all, main = "All")
  
  sqrt(mean(mD_D.nb$residuals^2))
  sqrt(mean(mD_D.nb.slope$residuals^2)) # slightly worse than base model
  sqrt(mean(mD_D.nb.elev$residuals^2))
  sqrt(mean(mD_D.nb.solar$residuals^2)) 
  sqrt(mean(mD_D.nb.all$residuals^2)) # lowest
  
  summary(mD_D.nb.all)
  summary(mD_D.nb)
  summary(mD_D.nb.solar)
  summary(mD_D.nb.elev)
  summary(mD_D.nb.slope)

  model_parameters(mD_D.nb.all)
  dev.off()
```

```{r basal area bring in covariates}
# bringing in data
  ba <- read.csv(("ba.csv"), stringsAsFactors = F)
 
  # removing unburned sites
  ba <- ba[ba$TREAT != 0,]
  
  # looking at format of data, first three rows
  ba[1:3,]
  
   DECID_BA <- subset(ba, ba$DIV == "d")

  # expansion factor. Make sure this is correct if you stick with this value.  
  # remember the expansion factor is the same as the inverse of the plot size relative to a ha,
  # so a 400m2 plot is 1/25 of a ha, so the expansion factor is 25.  

  DECID_BA$QUAD[DECID_BA$QUAD == 2] <- 50	#assuming a plot is 1/25 of a ha, so half a plot is 1/50 of a ha.
  DECID_BA$QUAD[DECID_BA$QUAD == 1] <- 100
  DECID_BA$QUAD[DECID_BA$QUAD == .1] <- 1000
  DECID_BA$QUAD[DECID_BA$QUAD == .2] <- 500
 
  #calc basal area
  DECID_BA$BA <- (pi * (DECID_BA$DBH/2)^2)/10000	#convert to ba and cm2 to m2. Just pi*r2
  DECID_BA$BA_ha <- DECID_BA$BA * DECID_BA$QUAD		#multiply by expansion factor 
  

  ba.plot <- aggregate(DECID_BA$BA_ha, list(DECID_BA$PLOT), FUN = sum)  	#adds up the count per ha for each row within a plot
  ba.trt <- aggregate(DECID_BA$TREAT, list(DECID_BA$PLOT), FUN = mean)		#gets the treatment number (mean works because they are the same

  DECID_ba_new <- cbind(ba.plot, ba.trt[,2])						#combines
  names(DECID_ba_new) <- c("PLOT","BA","TREAT")

  ba.site <- cbind(DECID_BA$SITE,DECID_BA$PLOT)
  temp <- as.data.frame(ba.site[!duplicated(ba.site[,2]),])
  names(temp) <- c("SITE","PLOT")

  DECID_BA <- merge(DECID_ba_new,temp,by="PLOT")	#double check all is well with the rows - right site/treatment/value
  
  #histogram
  hist(DECID_BA$BA)

  # pulling in site attribute variables
    attrib <- read.csv(here("data/site_attrib.csv"))
    
    # no unburned
    attrib <-attrib[attrib$TREAT != 0,]
    
    # getting order of sites in dens
    order <- as.vector(DECID_BA$PLOT) # don't worry that its 42, remember this doesnt include unburned
    attrib <- attrib %>%
      group_by(SITE, TREAT) %>%
      arrange(match(PLOT,order)) 
    # adding in attributes to density file
    DECID_BA$SLOPE <- attrib$SLOPE
    DECID_BA$ELEV <- attrib$ELEVATION
    DECID_BA$SOLAR <- attrib$SOLAR
```

